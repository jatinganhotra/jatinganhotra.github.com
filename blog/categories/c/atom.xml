<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C | blog@silverSpoon]]></title>
  <link href="http://jatinganhotra.com/blog/categories/c/atom.xml" rel="self"/>
  <link href="http://jatinganhotra.com/"/>
  <updated>2014-02-06T22:22:05+05:30</updated>
  <id>http://jatinganhotra.com/</id>
  <author>
    <name><![CDATA[Jatin Ganhotra]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Comparison is always false due to limited range of data type]]></title>
    <link href="http://jatinganhotra.com/blog/2013/07/21/comparison-is-always-false-due-to-limited-range-of-data-type/"/>
    <updated>2013-07-21T21:17:00+05:30</updated>
    <id>http://jatinganhotra.com/blog/2013/07/21/comparison-is-always-false-due-to-limited-range-of-data-type</id>
    <content type="html"><![CDATA[<p><link href='http://fonts.googleapis.com/css?family=Coming+Soon&subset=latin,latin-ext' rel='stylesheet' type='text/css'></p>

<div>
<span style="float:right;" id="google_translate_element"></span>
<span style="float:right; font-family: 'Coming Soon', cursive;">Having trouble viewing in English, Choose Your Language : &nbsp;&nbsp;&nbsp;</span>
</div>


<BR>&nbsp;<BR>


<p>This is a small and crisp post over this warning message that appeared quite strange at first. On a closer look though, the reason behind it was pretty clear and straight-forward.</p>

<blockquote><p>warning: comparison is always false due to limited range of data type</p></blockquote>

<p>I was just playing around with <code>string.find()</code> function, when I got this warning message.
Here is a simple piece of code which, when run on a 64-bit architecture, will produce the above warning.</p>

<p>``` c</p>

<pre><code>string subject = "A[1]";
string search = "1";
unsigned location = subject.find(search);    // location is unsigned
if( location == std::string::npos)
    cout &lt;&lt; " true";
else
    cout &lt;&lt; " false";
</code></pre>

<p>```</p>

<p>The catch here is that <code>std::string::npos</code> returns <code>size_t</code>, which represents the unsigned native integer size on current architecture.<br/>
So, on a 32-bit architecture:<br/>
 - both <code>unsigned</code> and <code>size_t</code> would have the same size,<br/>
However, on a 64-bit machine:<br/>
 - the <code>unsigned</code> would be size - 4 and <code>size_t</code> would be size - 8.<br/>
Hence, the comparison would be always false when run on a 64-bit machine.</p>

<p>So, the proper fix for the above code is to make location variable of type <strong>size_t</strong>.</p>

<p>For more information on <code>size_t</code>, refer to my blog post on <a href="http://jatinganhotra.com/blog/2012/08/25/integer-limits-and-types-in-c-cpp/">Integer Limits and Types in C/C++</a> , which explains the sizes of basic C++ types.</p>

<p><em>Note:</em> If you're seeing the same warning message, but not around the <code>string.find()</code> function, try <strong>StackOverflow</strong> for help. The warning message is generic and can occur at places where a comparison is being done between types of different sizes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ - Variable Declaration in 'if' expression]]></title>
    <link href="http://jatinganhotra.com/blog/2013/02/09/c-plus-plus-variable-declaration-in-if-expression/"/>
    <updated>2013-02-09T09:16:00+05:30</updated>
    <id>http://jatinganhotra.com/blog/2013/02/09/c-plus-plus-variable-declaration-in-if-expression</id>
    <content type="html"><![CDATA[<p><link href='http://fonts.googleapis.com/css?family=Coming+Soon&subset=latin,latin-ext' rel='stylesheet' type='text/css'></p>

<div>
<span style="float:right;" id="google_translate_element"></span>
<span style="float:right; font-family: 'Coming Soon', cursive;">Having trouble viewing in English, Choose Your Language : &nbsp;&nbsp;&nbsp;</span>
</div>


<BR>&nbsp;<BR>


<p>Recently, I encountered a strange compiler error at work. I was trying something similar to this:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="kt">int</span> <span class="n">var1</span> <span class="o">=</span> <span class="n">func1</span><span class="p">()</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">func2</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">{</span> <span class="c1">// Use var1 and var2 here - Doesn&#39;t compile }</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
but, it didn't compile. So, I played my Jedi debugging tricks to see
what exactly went wrong?<br/>
To my surprise,
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">func2</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>  <span class="p">{</span> <span class="c1">//... } // Doesn&#39;t compile, note the extra ()</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span> <span class="kt">int</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">func2</span><span class="p">()</span> <span class="p">)</span>      <span class="p">{</span> <span class="c1">//... } // Compiles just fine !!!</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
Now, it was well clear that <code>()</code> was the pith of the error.<br/>
To strengthen my understanding, I tried some more cases with <code>()</code>:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Variable declaration inside (), both cases don&#39;t compile</span>
</span><span class='line'><span class="n">bool</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span><span class="p">);</span>           <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="n">cout</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span>  <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">4</span><span class="p">);</span>      <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
The results were affirmative. So, I went to check the C++ Standard.<br/>
The syntax specification in 6.4/1 gives the following for selection condition:<br/>
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>selection-statement:
</span><span class='line'>if ( condition ) statement&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>condition: 
</span><span class='line'>    expression
</span><span class='line'>    type-specifier-seq declarator = assignment-expression
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>// The declarator shall not specify a function or an array.
</span><span class='line'>// The type-specifier-seq shall not contain typedef and shall not declare a new class or enumeration.</span></code></pre></td></tr></table></div></figure></notextile></div>
The condition in an if or while statement can be either an expression, or a single variable declaration (with initialisation).</p>

<p>The failing examples are neither valid statements, nor valid declarations, since a declaration can't form part of an expression. The syntax specification says a single declaration, with no parentheses or other adornments and they don't fit the "either expression or declaration" rule for the condition.</p>

<p>So, to sum it up, the <strong>rules for variable declaration in a selection-statement</strong> are:</p>

<ol>
<li>can only have 1 variable declared per expression,</li>
<li>the variable declaration must occur first in the expression and</li>
<li>can't have parenthesis around declaration ( as per the syntax specification)</li>
</ol>


<p><strong>Q</strong>. <em>Why the variable declaration must occur first, and why can we have only 1 variable declared?</em><br/>
<strong>A:</strong> Short-circuit evaluation of logic and the declared variable(s) scope. Consider this case:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">val</span><span class="p">))</span> <span class="p">{</span> <span class="c1">//... }    // what should &quot;a&quot; be initialized to?</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
The <code>&amp;&amp;</code> operator is a <em>short-circuit logical AND</em>. As the first part 0 is false, then the second part <code>(int a = val)</code> shouldn't be evaluated because the final answer will be false. If it isn't evaluated, then what to do with code later on that uses a? Should we initialize the variable and leave it undefined?</p>

<p>For these reasons, the variable declaration must be first in the expression and the rules for variable declaration in a selection-statement stated above hold.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Integer Limits and Types In C/C++]]></title>
    <link href="http://jatinganhotra.com/blog/2012/08/25/integer-limits-and-types-in-c-cpp/"/>
    <updated>2012-08-25T10:20:00+05:30</updated>
    <id>http://jatinganhotra.com/blog/2012/08/25/integer-limits-and-types-in-c-cpp</id>
    <content type="html"><![CDATA[<p><link href='http://fonts.googleapis.com/css?family=Coming+Soon&subset=latin,latin-ext' rel='stylesheet' type='text/css'></p>

<div>
<span style="float:right;" id="google_translate_element"></span>
<span style="float:right; font-family: 'Coming Soon', cursive;">Having trouble viewing in English, Choose Your Language : &nbsp;&nbsp;&nbsp;</span>
</div>


<BR>&nbsp;<BR>


<p>Unlike <a href="http://java.com/en/">Java</a> or <a href="http://en.wikipedia.org/wiki/C_Sharp_(programming_language">C#</a>, <a href="http://en.wikipedia.org/wiki/Primitive_data_type">primitive data types</a> in C++ can vary in size depending on the platform. For example, int is not guaranteed to be a 32-bit integer. The size of basic C++ types depends on</p>

<ul>
<li><h3><strong>The Architecture</strong> (16 bits, 32 bits, 64 bits) and</h3></li>
</ul>


<p>You can expect <a href="http://en.cppreference.com/w/cpp/types/size_t">std::size_t</a> to always represent the unsigned native integer size on current architecture. i.e. 16-bit, 32-bit or 64-bit. e.g<br/>
On a x64-bit machine, with <em>x86_64</em> hardware-platform and processor,
<code>sizeof(std::size_t) == sizeof(unsigned int) == 8 </code><br/>
where as, on a 32-bit machine, with <em>i386</em> hardware-platform and <em>i686</em> processor,
<code>sizeof(std::size_t) == sizeof(unsigned int) == 4 </code><br/>
But as far as all the other built-in types go, it really depends on the compiler.</p>

<ul>
<li><h3><strong>The Compiler</strong></h3></li>
</ul>


<p>The C++ standard does not specify the size of integral types in bytes, but it specifies minimum ranges they must be able to hold. You can infer minimum size in bits from the required range and the value of <code>CHAR_BIT</code> macro in &lt;<a href="http://en.cppreference.com/w/cpp/header/climits">climits</a>>, that defines the number of bits in a byte (in all but the most obscure platforms it's 8).<br/>
<em>An important point</em> to note for <code>char</code> is that its size is always 1 byte, or <code>CHAR_BIT</code> bits (hence the name). char is always a byte , but it's not always an octet. <em>A byte is the smallest addressable unit of memory (in most definitions), an octet is 8-bit unit of memory.</em>
i.e <code>sizeof(char) == 1</code> for all implementations, but <code>CHAR_BIT</code> defines the size of a byte for a platform and it's not always 8 bit. There are platforms with 16-bit and 32-bit bytes, hence char will take up more than 8 bits, but it is still a byte.</p>

<p>A C++ (or C) implementation can define the size of a type in bytes <code>sizeof(type)</code> to any value, as long as</p>

<ol>
<li>the expression <code>sizeof(type) * CHAR_BIT</code> evaluates to the number of bits enough to contain required ranges, and</li>
<li>the ordering of type is still valid (e.g. <code>sizeof(int) &lt;= sizeof(long)</code>).</li>
</ol>


<p>The actual implementation-specific ranges can be found in &lt;<a href="http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html">limits.h</a>> header in C, or &lt;<a href="http://en.cppreference.com/w/cpp/header/climits">climits</a>> in C++ (or even better, templated <a href="http://en.cppreference.com/w/cpp/types/numeric_limits">std::numeric_limits</a> in &lt;<a href="http://en.cppreference.com/w/cpp/header/limits">limits</a>> header).
Minimum ranges <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf">required by the standard</a> (page 22) can be found using this C++ snippet:</p>

<p><a href="https://gist.github.com/4368027">GIST - C++ snippet - Listing of MIN/MAX values, attributes of Integral Types</a>.</p>

<h3><strong>Portability</strong></h3>

<p>If you are concerned with portability and want guaranteed size, or you want the name of the type reflects the size,</p>

<ul>
<li>You can use the header <a href="http://www.boost.org/doc/libs/1%5F40%5F0/libs/integer/cstdint.htm">BOOST cstdint</a>. It's usually better than inventing your own wheel(which incurs the maintainence and testing), or</li>
<li>You can use the header &lt;<a href="http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.2/cinttypes-source.html">cinttypes</a>>, where the following macros are available: <code>int8_t, int16_t, int32_t, uint8_t, uint16_t, uint32_t</code> etc.<br/>
For more information on this, refer <a href="http://en.wikipedia.org/wiki/Inttypes.h#inttypes.h">Wiki- Inttypes.h</a>.</li>
</ul>

]]></content>
  </entry>
  
</feed>
